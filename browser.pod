=head1 NAME

browser - a www browser plugin for vim

=head1 SYNOPSIS

This plugin provides basic web browsing and html viewing capabilities. It uses 
vim's ability to embed perl, and perl's http modules. The full list of 
dependencies is available in the attached F<INSTALL> file.

Example:

        :Browse vim.sf.net

will open a well known web site.

=head2 DOCUMENTATION

This help text is translated from the F<browser.pod> file in the package 
directory.  You can use that file for viewing the documentation from the 
command line, like this:

        perldoc browser.pod

You can also translate it to various formats using the various pod2* 
programs.

=head1 Introduction

All functionality is available via commands, and some of them have default 
keymappings. I tried to make the mappings as compatible as possible with 
tags.

Similarly, I tried to maintain an analogy between browser windows (which can 
be thought of as browser instances, or windows, or tabs) and vim windows, and 
between web pages and vim buffers.

Unless stated otherwise, all commands are global, ie, they work in any 
window, not only a browser window. Usually, the affected browser window will 
be the last one that was active (if the currently active window is a browser 
window, it will affected).

=head1 Opening a new web page

=over

=item :Browse {uri}

Open the page with the given {uri}. If there is an open browser window, open 
it there, otherwise open a new browser window (similarly to the I<:help> 
command). The height of the window is given by the C<helpheight> option. The 
{uri} specification may contain also bookmarks, see L</"Uri format"> for 
details. The page will be displayed according to its content type, see 
L</"Content-Type handling"> and L</"HTML formatting">. Alternatively, if a 
handler for the given scheme is defined, use it instead of opening, see 
L</SCHEMES>.

If the page was already opened, it will not be loaded again, use L</:Reload> 
if you want to reload it.

=item :SBrowse[!] {uri}

Same as L</":Browse {uri}">, but force splitting a new window, even if an  
existing browser window exists. If B<!> is given, split vertically.

=item :Reload

Reload the current page. If fetching the page failed, leaves the old content.

=item CTRL-] X<browser-CTRL-]>

=item g<LeftMouse> X< browser-gE<lt>LeftMouseE<gt> >

=item <C-LeftMouse> X< browser-E<lt>C-LeftMouseE<gt> >

=item :Follow

Follow the link currently under the cursor. Obeys the same rules as 
L</":Browse {uri}">. (In particular, the L</"Content-Type handling"> rules 
apply.)

Naturally, this command will only work when the currently active window is a 
browser window.

=item :SaveLink [file]

Instead of opening the link under the cursor, save it to a file, given by 
[file]. If [file] is not given, the user is prompted to give one. This will 
also happen if you L</:Follow> a link whose content type is not supported.

Note that this will not work if an external handler is defined for the scheme 
of the link (see L</SCHEMES>).

=back

=head2 Content-Type handling

The correct way to display the contents of a given page depends on its 
content type. Currently, this plugin supports only two content types: 
B<text/plain> and B<text/html>. B<text/plain> is displayed as is.  
B<text/html> is translated to plain text with some minor markup. See
L</"HTML formatting"> for details about that.

If the content type is not supported, the contents will be saved to a file 
instead, as if L</:SaveLink [file]> was used (with no [file]).

=head1 History

The browser history is supposed to resemble the tags I<tags> mechanism.

=over

=item CTRL-T X<browser-CTRL-T>

=item g<RightMouse> X< browser-gE<lt>RightMouseE<gt> >

=item <C-RightMouse> X< browser-E<lt>C-RightMouseE<gt> >

=item :[N]Back

=item :[N]Pop

Go back N items in the history of the current window. N defaults to 1.

=item :[N]Forward

=item :[N]Tag

Go forward N items in the history of the current window. N defaults to 1.

=item :History

=item :Tags

Show the history of the current window.

=back

=head1 Uri format

Whenever a uri is required, the uri may have one of several forms. Any 
complete uri is acceptable. However, the plugin uses B<URI::Heuristic> to 
expand anything that does not start with a B<:>, so most things another 
browser would accept, are also acceptable here. If the uri contains a scheme 
(like B<http:>), it is not modified. See the documentation of 
B<URI::Heuristic> for details. Uris starting with B<:> are reserved for 
bookmarks.

=head2 BOOKMARKS

The bookmark system works as follows: Bookmarks are stored in files, which 
reside in the directory given by L</g:browser_addrbook_dir>. Each file in 
that directory that does not start with B<.> is considered a bookmarks file.  
Each such file contains a list of aliases to uris. You can then use the 
syntax B<:E<lt>fileE<gt>:E<lt>aliasE<gt>> for a uri. For example, if you have 
a bookmark file called F<software> which contains an alias B<vim> to 
F<http://vim.sf.net>, then

        :Browse :software:vim

is equivalent to

        :Browse http://vim.sf.net

Additionally, there is always a B<current> bookmark file, initially given by 
L</g:browser_default_addrbook>, whose name can be omitted. So in the above 
example, if F<software> is the current file, you can write

        :Browse ::vim

In fact, you can also drop one of the B<:>, but the command line completion 
will complete bookmark files and not aliases.

The structure of the bookmark file is very simple:

        <alias> <uri> <text>

Where B<alias> is the alias, B<uri> is the uri to which it expands (both may 
not contain whitespace), and the rest of the line is a comment (usually the 
title of the web page). The line should start in the first column. Lines that 
have B<#> in the first column are ignored and can be used as comments, but 
note that, at least currently, if you change or delete a bookmark from within 
vim, this file is overwritten, and all comments are lost.

If this file is modified outside of vim after it was used in a session, the 
changes won't be take place until you restart vim.

The B<uri> field in the bookmark file may contain anything that is valid as a 
uri, including other bookmarks, which are expanded recursively.

=over

=item :Bookmark {alias}

Add a bookmark of the current page to the current bookmark file, under the 
alias {alias}. If there is already an alias by that name, it will be 
replaced.

=item :Bookmark! {alias}

Delete the given alias from the current bookmark file.

=item :AddrBook[!] {name}

Change the current bookmark file to be the one given by {name}. {name} is the 
name of a file in the directory specified by L</g:browser_addrbook_dir>, as 
explained above. If the file does not exist, the command fails, unless B<!> 
is given, in which case it is created.

=item :ListBookmarks [name]

List all bookmarks in the bookmark file specified by [name]. If [name] is 
omitted, the current file is used.

=back

=head1 Miscellaneous commands

=over

=item :ShowHeader

Show some of the header fields in the current page.

=item :HideHeader

Hide fields that were displayed by L</:ShowHeader>.

=item :ViewSource[!]

Open a new window, with the source of the current page displayed. If B<!> is 
given, split vertically.

=item :[N]NextLink

Jump to the N-th next link, from the current cursor position. N defaults to 
1. Works only in a browser window.

=item :[N]PrevLink

Same as L</:[N]NextLink>, but backwards.

=back

=head1 Functions

The functions mainly correspond to the command. I will only detail here some 
function that don't.

=over

=item ShowLinkTarget()

Show the uri of the link currently under the cursor. This is called when 
there was no keypress for C<updatetime> ms, via the I<CursorHold> event.

=item CompleteBkmkFile()

Lists all bookmark files. Used for completion of bookmark file names in 
commands.

=item CompleteBrowse()

Returns completion lists, for complete a uri. This will list bookmark files, 
bookmarks or files, depending on the number of B<:> in the initial segment.  
See I<:command-completion-custom> for details about the arguments and return 
type of this and the previous function.

=back

=head1 Settings

All settings are controlled by global variables whose name start with 
B<browser_>. Examples and default values are given in the beginning of the 
F<browser.vim> plugin.

=over

=item g:browser_addrbook_dir

Default: F<$HOME/.vim/addressbooks/>.

The directory where bookmark files are stored. Any (non-hidden) file in this 
directory is considered to be a bookmarks file. See L</BOOKMARKS> for 
details.

=item g:browser_default_addrbook

Default: F<default>

The default B<current> bookmarks file. See L</BOOKMARKS> for details.

=item g:browser_from_header

Default: B<$EMAIL>

The e-mail address to send in the GET request for web pages.

=item g:browser_assumed_encoding

Default: B<utf-8>

The web page encoding to assume, if it can not be deduced from the page 
headers.

=back

=head2 HTML formatting

If the type of the page is html, the plugin will translate it to text, with 
some simple markup, and will use syntax highlighting accordingly. Some of 
this markup is hard-coded (for example, links will always appear between 
B<E<lt>E<lt>> and B<E<gt>E<gt>>). But some of it can be controlled by the 
settings bellow:

=over

=item g:browser_{attr}_start

Define the markup for the start of a text with the given attribute. This is 
the text that will occur before the actual text with this attribute. See 
L</"Html attributes"> for the list of possible attributes.

=item g:browser_{attr}_end

Define the markup for the end of a text with the given attribute. This must 
exist whenever the corresponding L</g:browser_{attr}_start> exists.

=item g:browser_{attr}_highlight

The highlight group to use for text with this attribute. This can be omitted, 
and then the highlighting should be defined manually. The highlight group is 
called browser_{attr}.

=back

The text given by the start and end variables will be highlighted with the 
B<Ignore> group, and if you have the B<conceal> patch (try I<:syn-conceal>), 
it will be concealed.

Note that there is a difference between defining L</g:browser_{attr}_start> 
to be empty, and not defining it at all: In the first case, there will 
certainly be no markup. In the second, markup may be inherited from a 
different attribute, as summarized in L</"Html attributes">.

Example: the plugin defines the following defaults:

        let g:browser_bold_start='_*'
        let g:browser_bold_end='*_'
        let g:browser_bold_highlight='Bold'
        let g:browser_italic_start='_/'
        let g:browser_italic_end='/_'
        let g:browser_italic_highlight='UnderLine'

This implies that italic text will appear like _/this/_ in the translated 
text, and will be highlighted with the B<UnderLine> group (except for the 
B<_/> and B</_>, which will be hidden). On the other hand, 
B<g:browser_em_start> is not defined, so it will appear the same as italic.

=head3 Html attributes

The following table summarizes the possible attributes. The first column 
gives the attribute name, as should appear in the variable name. The second 
column gives the corresponding HTML tag. The third column gives the fallback 
attribute, in case L</g:browser_{attr}_start> is undefined.

        attr            tag             fallback
        -----------------------------------------
        bold            b
        italic          i
        teletype        tt
        strong          strong          bold
        em              em              italic
        code            code            teletype
        kbd             kbd             teletype
        samp            samp            teletype
        var             var             teletype

=head2 SCHEMES

The B<scheme> of a uri is its first component, eg, B<http>. In principle, the 
plugin can fetch the contents of a uri with any scheme except for B<mailto> 
(where it makes no sense). However, usually that's not desirable, since there 
are only few content types that the plugin supports. For example, for an 
B<ftp> uri of a remote directory, what you really want is to enter the 
directory, get some files, etc.

X<browser-handlers>
For this reason, it is possible to define external handlers associated with a 
given scheme.

=over

=item g:browser_{scheme}_handler

Define the external program given by the value of this variable to handle 
uris with scheme {scheme}. The escape sequence B<%s> will be replaced by the 
full uri in question.

=back

Once a handler is defined, it is used whenever a uri of this type is 
requested (eg, in L</":Browse {uri}"> commands, when following a link, etc.).  
This is done after the uri expansion, so bookmarks whose target is such a uri 
are affected as well.

For example, the definition

        let g:browser_mailto_handler = 'xterm -e mutt %s &'

in the plugin will cause B<mutt(1)> to be opened in a an B<xterm(1)> whenever 
a B<mailto:> plugin is encountered. Note the B<E<amp>> in the end, which 
allows you to continue browsing while the program is open.

=head1 VERSION

For vim version 6.3

=head1 AUTHOR

Moshe Kaminsky <kaminsky@math.huji.ac.il>


